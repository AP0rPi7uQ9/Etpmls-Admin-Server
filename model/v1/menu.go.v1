package model

import (
	"Etpmls-Admin1-Server/database"
)

func MenuGetAllV1() []JsonMenuGetAllV1 {
	var menus []Menu
	database.DB.Preload("Roles").Find(&menus)

	var m []JsonMenuGetAllV1
	var current JsonMenuGetAllV1
	for _, v := range menus {
		current.ID = v.ID
		current.ParentId = v.ParentId
		current.Path = v.Path
		current.Component = v.Component
		current.Name = v.Name
		current.AlwaysShow = v.AlwaysShow
		current.Redirect = v.Redirect
		current.Hidden = v.Hidden

		current.Meta.Title = v.Title
		current.Meta.Icon = v.Icon
		current.Meta.NoCache = v.NoCache
		current.Meta.Affix = v.Affix
		current.Meta.BreadCrumb = v.Breadcrumb
		current.Meta.ActiveMenu = v.ActiveMenu

		var tmp = []string{}
		// Handle Meta.Roles, Exclude ADMIN
		for _, v2 := range v.Roles {
			if v2.Name != "admin" {
				tmp = append(tmp, v2.Name)
			}
		}
		current.Meta.Roles = tmp

		// ADD admin to Meta.roles . Prevent duplication admin records before exclude
		current.Meta.Roles = append(current.Meta.Roles, "admin")

		m = append(m, current)
	}


	// 无限极分类
	tree := MenuGetTreeV1(m)

	return tree
}

func MenuCreateV1(j JsonMenuCreateV1) (id uint, err error) {
	type Menu JsonMenuCreateV1
	// Create Route
	form := Menu(j)
	// Tmp Field, because gorm can't update stuct data
	form.Title = form.Meta.Title
	form.Icon = form.Meta.Icon

	if err = database.DB.Create(&form).Error; err != nil {
		return id, err
	}

	return form.ID, err
}

func MenuDeleteV1(u UriMenuDeleteV1) (err error) {
	type Menu UriMenuDeleteV1
	form := Menu(u)

	if err = database.DB.Delete(&form).Association("Roles").Clear().Error; err != nil {
		return err
	}

	return err
}

func MenuEditV1(j JsonMenuEditV1) (id uint, err error) {
	type Menu JsonMenuEditV1
	form := Menu(j)
	database.DB.First(&form, j.ID)

	form.ParentId = j.ParentId
	form.Hidden = j.Hidden
	form.Redirect = j.Redirect
	form.AlwaysShow = j.AlwaysShow
	form.Name = j.Name
	form.Path = j.Path
	form.Component = j.Component
	// Tmp Field, because gorm can't update stuct data
	form.Title = j.Meta.Title
	form.Icon = j.Meta.Icon


	if err := database.DB.Save(&form).Error; err != nil {
		return id, err
	}

	return form.ID, err
}

// 无限极分类
// https://www.itlipeng.cn/2017/06/10/golang-%E7%89%88%E6%97%A0%E9%99%90%E7%BA%A7%E8%8F%9C%E5%8D%95%E5%88%86%E7%B1%BB/comment-page-1/
func MenuGetTreeV1(data []JsonMenuGetAllV1) []JsonMenuGetAllV1 {
	d := menuBuildDataToTreeV1(data)
	tree := menuMakeTreeByBuildDataV1(0, d)
	return tree
}

func MenuGetTreeByMenusV1(menus []Menu) []JsonMenuGetAllV1 {
	var m []JsonMenuGetAllV1
	var tmp JsonMenuGetAllV1
	for _, v := range menus {
		tmp.ID = v.ID
		tmp.ParentId = v.ParentId
		tmp.Path = v.Path
		tmp.Component = v.Component
		tmp.Name = v.Name
		tmp.AlwaysShow = v.AlwaysShow
		tmp.Redirect = v.Redirect
		tmp.Hidden = v.Hidden
		tmp.Component = v.Component

		var s []string
		for _, v := range v.Roles {
			s = append(s, v.Name)
		}
		tmp.Meta.Roles = s

		m = append(m, tmp)
	}
	tree := MenuGetTreeV1(m)
	return tree
}

func menuBuildDataToTreeV1(m []JsonMenuGetAllV1)  map[uint]map[uint]JsonMenuGetAllV1 {
	var data = make(map[uint]map[uint]JsonMenuGetAllV1)
	for _, v := range m {
		id := v.ID
		parent_id := v.ParentId
		if _, ok := data[parent_id]; !ok {
			data[parent_id] = make(map[uint]JsonMenuGetAllV1)
		}
		data[parent_id][id] = v
	}
	return data
}

func menuMakeTreeByBuildDataV1(index uint, data map[uint]map[uint]JsonMenuGetAllV1) []JsonMenuGetAllV1 {
	tmp := make([]JsonMenuGetAllV1, 0)
	for id, item := range data[index] {
		if data[id] != nil {
			item.Children = menuMakeTreeByBuildDataV1(id, data)
		}
		tmp = append(tmp, item)
	}
	return tmp
}

// Get all children menu in one (1 level) slice By Menu List
func MenuGetChildrenByMenuV1(parent_id uint, menu_list []JsonMenuGetAllV1, store *[]JsonMenuGetAllV1)  {
	for _, v := range menu_list {
		if v.Children != nil {
			MenuGetChildrenByMenuV1(v.ID, v.Children, store)
		}
		// 无论如何，菜单父级都是从0开始，所以从0开始搜索没问题，
		v.ParentId= parent_id
		*store = append(*store, v)
	}
	return
}







